/*
 * $Header: /cvsroot/wsplan/wsplan/src/org/mcm/sws/pddl/ActionInstance.java,v 1.2 2004/12/01 16:14:51 joepeer Exp $
 * $Date: 2004/12/01 16:14:51 $
 *
 * WSPlan - Automatic Web Service Composition
 * Copyright (C) MCM institute, University of St. Gallen
 * Written by Joachim Peer
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */


package org.mcm.sws.pddl;


import org.apache.log4j.Logger;

import java.util.*;
import org.mcm.sws.annotation.*;
import org.mcm.sws.wsdl.*;
import org.mcm.sws.*;

/**
 * An ActionInstance holds information about a web service operation and
 * the concrete parameters to call that information. An ActionInstance is
 * similar to a step in a plan (a plan step). In fact, ActionInstances are
 * generated by interpreting the output of a planner, i.e. a sequential plan.
 * The ActionInstances are then passed to ServiceExec2 and then executed.
 *
 * <p>this structure is NOT parsed by the formula.jj - parser.
 * (it is parsed by the little plan parser)</p>
 *
 * <pre>
 * Example: VHPOP output
 *
 * ;generic_problem1
 * 1:(login secret123 joepeer)
 * 2:(buystock q2323 voest)
 * 3:(achieve-goal)
 * Time: 0
 *</pre>
 *
 * @author    Joachim Peer
*/

public class ActionInstance {
	private static Logger log = Logger.getLogger(ActionInstance.class);

	public static int INITIAL = 0;
	public static int FINAL = 1;

	//protected String name;
	protected List params;
	protected int stepID;

	// reference to operation (WSDL)
	protected Operation operation;
	// reference to opDef (annotation)
	protected OpDef opDef;

	public ActionInstance() {
		params = new ArrayList();
	}

	public void addParam(String s) {
		params.add(s);
	}

	public List getParams() {
		return params;
	}

	public void setStepID(int stepID) {
		this.stepID = stepID;
	}

	public int getStepID() {
		return stepID;
	}


	public void setOpDef(OpDef opDef) {
		this.opDef = opDef;
	}

	public OpDef getOpDef() {
		return opDef;
	}

	public void setOperation(Operation operation) {
		this.operation = operation;
	}

	public Operation getOperation() {
		return operation;
	}

	/*


	public void resolveUnboundVariables() {
		for(int i = 0; i<params.size(); i++) {
			String param = (String) params.get(i);
			if(param.indexOf('?') == 0) {
				System.out.println("Trying to resolve paramter "+param);
				//Predicate f = opDef.getAtomicPreconditionFormula(param);
				String value = ExecEnvironment.evaluate(opDef, param);
				if(value != null) {
					System.out.println("substituting with..."+value);
					params.add(i, value);
				} else {
					System.out.println("could not bind!");
				}
			}
		}
	}	*/


/* better use default, ie. return (o == this);
	public boolean equals(Object o) {

		if(!(o instanceof ActionInstance)) return false;
		ActionInstance other = (ActionInstance) o;
		if(!other.operation.getURI().equals(operation.getURI())  ||
			 other.params.size() != params.size()) {
				 return false;
		}

		for(int i = 0; i < params.size(); i++) {
			String s1 = (String) params.get(i);
			String s2 = (String) other.params.get(i);
			if(! s1.trim().equals(s2.trim())) {
				return false;
			}
		}

		return true;


	}
*/
	public int hashCode() {
		int result = 0;

		if(this.operation != null)
			result = this.operation.getURI().hashCode();

		for(Iterator iter = params.iterator(); iter.hasNext(); ) {
			Object o = iter.next();
			result += ((String) o).hashCode();
		}

		return result;
	}


	public String toString() {
		StringBuffer buf = new StringBuffer();
		buf.append("step ");
		buf.append(stepID);
		buf.append(": (uri=");
		if(operation != null)
			buf.append(operation.getURI());
		for(Iterator iter = params.iterator(); iter.hasNext(); ) {
			buf.append(" ");
			String bp = (String) iter.next();
			buf.append(bp);
		}
		buf.append(")");
		return buf.toString();
	}

}
